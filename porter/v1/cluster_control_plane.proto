syntax = "proto3";

package porter.v1;

import "google/protobuf/timestamp.proto";
import "porter/v1/aws_assume_role.proto";
import "porter/v1/cloud_provider_credentials.proto";
import "porter/v1/cluster.proto";
import "porter/v1/contract.proto";
import "porter/v1/errors.proto";
import "porter/v1/gke.proto";
import "porter/v1/porter_app.proto";

message PreflightCheckRequest {
  int64 project_id = 1;
  // cloud_provider [REQUIRED] represents the provider that we will provisioning the cluster in
  EnumCloudProvider cloud_provider = 2;
  // cloud_provider_credentials_id [REQUIRED] is the Porter credentials that will be used for provisioning a cluster.
  // These must be stored within Porter, prior to cluster creation. For AWS this refers to the last link in an assume role chain
  string cloud_provider_credentials_id = 3;

  oneof preflight_values {
    //gke_preflight_values the values that GKE will use to perform preflight checks
    GKEPreflightValues gke_preflight_values = 4;
    //EKS eks_kind = 5;

    //AKS aks_kind = 6;
  }
}

message PreflightCheckResponse {
  // preflight_checks keys are name of preflight check and error will be if the preflight checks fails, nil if it passes
  map<string, Error> preflight_checks = 1;
}

message QuotaPreflightCheckRequest {
  option deprecated = true;
  int64 project_id = 1;
  string target_arn = 2;
  string external_id = 3;
  string region = 4;
}

message QuotaPreflightCheckResponse {
  option deprecated = true;
}

message CreateAssumeRoleChainRequest {
  option deprecated = true;

  int64 project_id = 1;
  string source_arn = 2;
  string target_access_id = 3;
  string target_secret_key = 4;
  string target_session_token = 5;
  string target_arn = 6;
  string external_id = 7;
}

message CreateAssumeRoleChainResponse {
  option deprecated = true;

  int64 project_id = 1;
  string target_arn = 2;
}

message SaveAzureCredentialsRequest {
  option deprecated = true;
  int64 project_id = 1;
  string client_id = 2;
  string subscription_id = 3;
  string tenant_id = 4;
  bytes service_principal_secret = 5;
}

message SaveAzureCredentialsResponse {
  option deprecated = true;

  int64 project_id = 1;
  string credentials_identifier = 2;
}

message KubeConfigForClusterRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message KubeConfigForClusterResponse {
  string kube_config = 1;
}

message UpdateContractRequest {
  Contract contract = 1;
}

message UpdateContractResponse {
  ContractRevision contract_revision = 1;
}

message ClusterStatusRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message ClusterStatusResponse {
  int64 project_id = 1;
  int64 cluster_id = 2;
  string phase = 3;
  bool infrastructure_status = 4;
  bool control_plane_status = 5;
}

message DeleteClusterRequest {
  ContractRevision contract_revision = 1;
}

message DeleteClusterResponse {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message ListRepositoriesForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message ListRepositoriesForRegistryResponse {
  repeated Repository repositories = 1;
}

message Repository {
  string name = 1;
  string uri = 3;
}

message ListImagesForRepositoryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
  string repo_name = 3;
}

message ListImagesForRepositoryResponse {
  repeated Image images = 1;
}

message Image {
  string repository_name = 1;
  string tag = 2;
}

message TokenForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message TokenForRegistryResponse {
  string token = 1;
  google.protobuf.Timestamp expiry = 2;
}

message ReadContractRequest {
  ContractRevision contract_revision = 1;
}

message ReadContractResponse {
  string base64_contract = 1;
}

message ValidatePorterAppRequest {
  int64 project_id = 1;
  string deployment_target_id = 2;
  string commit_sha = 3;
  PorterApp app = 4;
  Deletions deletions = 5;
}

message ValidatePorterAppResponse {
  PorterApp app = 1;
}

message ApplyPorterAppRequest {
  int64 project_id = 1;
  // deployment_target_id is the id of the deployment target where the app will be installed
  string deployment_target_id = 2;
  // app is the definition of the PorterApp to be applied
  PorterApp app = 3;
  // porter_app_revision_id is the id of the PorterAppRevision to be applied.  This is used by the CLI to provide updates to an existing app revision. If provided, app must be empty.
  string porter_app_revision_id = 4;
}

message ApplyPorterAppResponse {
  string porter_app_revision_id = 1;
  // cli_action is the action that the CLI should take after applying the PorterApp (at the time of writing, either build the image or track whether a predeploy job has completed)
  EnumCLIAction cli_action = 2;
}

// DeletePorterAppRequest is the request object when deleting a porter app from a given project
message DeletePorterAppRequest {
  // project_id is the id of the project that the PorterApp belongs to
  int64 project_id = 1;
  // app_name is the name of the porter app to be deleted
  string app_name = 2;
}

// DeletePorterAppResponse is the response object when deleting a porter app from a given project
message DeletePorterAppResponse {
  // app_id is the id of the PorterApp that was deleted
  int64 app_id = 1;
}

// DeleteAppDeploymentRequest is the request object when removing a porter app from a given deployment target
message DeleteAppDeploymentRequest {
  int64 project_id = 1;
  // deployment_target_id is the id of the deployment target where the app is being uninstalled from
  string deployment_target_id = 2;
  // app_name is the name of the porter app to be uninstalled
  string app_name = 3;
}

// DeleteAppDeploymentResponse is the response object when removing a porter app from a given deployment target
message DeleteAppDeploymentResponse {}

message CurrentAppRevisionRequest {
  int64 project_id = 1;
  // app_id is the id of the PorterApp that is currently installed
  int64 app_id = 2;
  // deployment_target_id is the id of the deployment target where the app is installed
  string deployment_target_id = 3;
}

message AppRevision {
  // app is the definition of the PorterApp that is currently installed
  PorterApp app = 1;
  // status is the status of the revision
  string status = 2;
  // revision_number is the revision number respective to the application and deployment target
  uint64 revision_number = 3;
  // created_at is the time the revision was created
  google.protobuf.Timestamp created_at = 4;
  // updated_at is the time the revision was last updated
  google.protobuf.Timestamp updated_at = 5;
}

message CurrentAppRevisionResponse {
  // revision is the currently deployed app revision for a given porter_app and deployment_target
  AppRevision app_revision = 1;
}

message ListAppRevisionsRequest {
  int64 project_id = 1;
  // app_id is the id of the PorterApp that is currently installed
  int64 app_id = 2;
  // deployment_target_id is the id of the deployment target where the app is installed
  string deployment_target_id = 3;
}

message ListAppRevisionsResponse {
  // app_revisions is the list of app revisions for the given app and deployment target
  repeated AppRevision app_revisions = 1;
}

message PredeployStatusRequest {
  int64 project_id = 1;
  // app_revision_id is the revision id of the PorterApp which should have its predeploy status checked
  string app_revision_id = 2;
}

message PredeployStatusResponse {
  // predeploy_status is the status of the predeploy job
  EnumPredeployStatus predeploy_status = 1;
}

enum EnumPredeployStatus {
  ENUM_PREDEPLOY_STATUS_UNSPECIFIED = 0;
  // ENUM_PREDEPLOY_STATUS_IN_PROGRESS signifies the predeploy is still in progress.
  ENUM_PREDEPLOY_STATUS_IN_PROGRESS = 1;
  // ENUM_PREDEPLOY_STATUS_FAILED signifies the predeploy job failed.
  ENUM_PREDEPLOY_STATUS_FAILED = 2;
  // ENUM_PREDEPLOY_STATUS_SUCCESSFUL signifies the predeploy job was successful.
  ENUM_PREDEPLOY_STATUS_SUCCESSFUL = 3;
}

enum EnumCLIAction {
  ENUM_CLI_ACTION_UNSPECIFIED = 0;
  // ENUM_CLI_ACTION_NONE signals the CLI to do nothing after applying the PorterApp.
  ENUM_CLI_ACTION_NONE = 1;
  // ENUM_CLI_ACTION_BUILD signals the CLI to build the image and call ApplyPorterApp again after a successful build.
  ENUM_CLI_ACTION_BUILD = 2;
  // ENUM_CLI_ACTION_TRACK_PREDEPLOY signals the CLI to track the progress of the predeploy job and call ApplyPorterApp again after a successful run.
  ENUM_CLI_ACTION_TRACK_PREDEPLOY = 3;
}

service ClusterControlPlaneService {
  // UpdateCloudProviderCredentials creates or updates the credentials used for accessing the specific cloud
  rpc UpdateCloudProviderCredentials(UpdateCloudProviderCredentialsRequest) returns (UpdateCloudProviderCredentialsResponse) {}

  // QuotaPreflightCheck checks if the target account and region has sufficient resources (EIP addresses and VPCs) to provision a new cluster
  rpc QuotaPreflightCheck(QuotaPreflightCheckRequest) returns (QuotaPreflightCheckResponse) {
    option deprecated = true;
  }

  // PreflightCheck checks if the target account is able to provision a cluster
  rpc PreflightCheck(PreflightCheckRequest) returns (PreflightCheckResponse) {}

  // CreateAssumeRoleChain creates a new assume role chain for a given project and checks if the target assumed role has sufficient permissions. Use UpdateCloudProviderCredentials instead.
  rpc CreateAssumeRoleChain(CreateAssumeRoleChainRequest) returns (CreateAssumeRoleChainResponse) {
    option deprecated = true;
  }

  // SaveAzureCredentials stores the new azure service principal credentials and creates the azure cluster identity. Deprecated. Use UpdateCloudProviderCredentials instead.
  rpc SaveAzureCredentials(SaveAzureCredentialsRequest) returns (SaveAzureCredentialsResponse) {
    option deprecated = true;
  }

  // KubeConfigForCluster gets a valid kubeconfig from the management cluster, for a given workload cluster
  rpc KubeConfigForCluster(KubeConfigForClusterRequest) returns (KubeConfigForClusterResponse) {}

  // UpdateContract takes in a Porter Contract, actioning upon it where necessary
  rpc UpdateContract(UpdateContractRequest) returns (UpdateContractResponse) {}

  // ReadContract returns the base64 encoded contract for a given cluster and project
  rpc ReadContract(ReadContractRequest) returns (ReadContractResponse) {}

  // ClusterStatus returns the status of a given workload cluster
  rpc ClusterStatus(ClusterStatusRequest) returns (ClusterStatusResponse) {}

  // DeleteCluster uninstalls system components from a given workload cluster before deleting it.
  // This should ultimately be wrapped into UpdateContract
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {}

  // TokenForRegistry returns a token for accessing a given registry
  rpc TokenForRegistry(TokenForRegistryRequest) returns (TokenForRegistryResponse) {}

  // ListRepositoriesForRegistry lists the repositories for a given registry, provided it is in the scope of the project id
  rpc ListRepositoriesForRegistry(ListRepositoriesForRegistryRequest) returns (ListRepositoriesForRegistryResponse) {}

  // ListImagesForRepository lists the repositories for a given registry, provided it is in the scope of the project id
  rpc ListImagesForRepository(ListImagesForRepositoryRequest) returns (ListImagesForRepositoryResponse) {}

  // ValidatePorterApp validates and hydrates a definition of a porter app, based on the porter.yaml file
  rpc ValidatePorterApp(ValidatePorterAppRequest) returns (ValidatePorterAppResponse) {}

  // ApplyPorterApp applies a porter app as defined by the provided porter.yaml file to a given deployment id
  rpc ApplyPorterApp(ApplyPorterAppRequest) returns (ApplyPorterAppResponse) {}

  // DeletePorterApp deletes all instances of a porter app across deployment targets in a given project
  rpc DeletePorterApp(DeletePorterAppRequest) returns (DeletePorterAppResponse) {}

  // DeleteAppDeployment deletes a porter app from a given deployment target
  rpc DeleteAppDeployment(DeleteAppDeploymentRequest) returns (DeleteAppDeploymentResponse) {}

  // CurrentAppRevision returns the currently deployed app revision for a given porter_app and deployment_target
  rpc CurrentAppRevision(CurrentAppRevisionRequest) returns (CurrentAppRevisionResponse) {}

  rpc ListAppRevisions(ListAppRevisionsRequest) returns (ListAppRevisionsResponse) {}

  // PredeployStatus returns the status of the predeploy job for a given app revision
  rpc PredeployStatus(PredeployStatusRequest) returns (PredeployStatusResponse) {}

  // DockerConfigFileForRegistry returns a stringified config.json for accessing a given registry.
  // Deprecated. Use TokenForRegistry instead.
  rpc DockerConfigFileForRegistry(DockerConfigFileForRegistryRequest) returns (DockerConfigFileForRegistryResponse) {
    option deprecated = true;
  }

  // ECRTokenForRegistry returns a docker-compatible token for accessing a given ECR registry.
  // This cannot be deleted before TokenForRegistry supports AWS and we edit RegistryGetECRTokenHandler to call that endpoint.
  // Deprecated. Use TokenForRegistry instead.
  rpc ECRTokenForRegistry(ECRTokenForRegistryRequest) returns (ECRTokenForRegistryResponse) {
    option deprecated = true;
  }

  // AssumeRoleCredentials should be used vary sparingly, and ONLY for replacing AWS Integrations which have no workaround on the Porter API.
  // This endpoint returns temporary AWS credentials for a given AWS Account ID, and should not be expanded further to allow specifc role selection without being tied to a project and cluster.
  // Deprecated. This is no longer needed once ListRepositoriesForRegistry, ListImages, and CreateRepository supports AWS
  rpc AssumeRoleCredentials(AssumeRoleCredentialsRequest) returns (AssumeRoleCredentialsResponse) {
    option deprecated = true;
  }

  // AssumeRoleChainTargets gets the final destination target_arns for a given project.
  // Deprecated. Do not use.
  rpc AssumeRoleChainTargets(AssumeRoleChainTargetsRequest) returns (AssumeRoleChainTargetsResponse) {
    option deprecated = true;
  }

  // CertificateAuthorityData gets the certificate authority data for a customer cluster
  rpc CertificateAuthorityData(CertificateAuthorityDataRequest) returns (CertificateAuthorityDataResponse) {
    option deprecated = true;
  }

  // EKSBearerToken gets a bearer token for programatic access to an EKS cluster's kubernetes API.
  // Deprecated. Use KubeConfigForCluster instead.
  rpc EKSBearerToken(EKSBearerTokenRequest) returns (EKSBearerTokenResponse) {
    option deprecated = true;
  }
}

message EKSBearerTokenRequest {
  option deprecated = true;
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message EKSBearerTokenResponse {
  option deprecated = true;
  string token = 1;
}

message CertificateAuthorityDataRequest {
  option deprecated = true;
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message CertificateAuthorityDataResponse {
  option deprecated = true;
  string certificate_authority_data = 1;
}

message AssumeRoleChainTargetsRequest {
  option deprecated = true;
  string project_id = 1;
}

message AssumeRoleChainTargetsResponse {
  option deprecated = true;
  repeated AssumeRoleChainLink chain_links = 1;
}

message ECRTokenForRegistryRequest {
  option deprecated = true;
  int64 project_id = 1;
  string region = 2;
  string aws_account_id = 3;
}

message ECRTokenForRegistryResponse {
  option deprecated = true;
  string token = 1;
  google.protobuf.Timestamp expiry = 2;
}

message AssumeRoleCredentialsRequest {
  option deprecated = true;
  string aws_account_id = 1;
  int64 project_id = 2;
}

message AssumeRoleCredentialsResponse {
  option deprecated = true;
  string aws_access_id = 1;
  string aws_secret_key = 2;
  string aws_session_token = 3;
}

message DockerConfigFileForRegistryRequest {
  option deprecated = true;
  int64 project_id = 1;
  string registry_uri = 2;
}

message DockerConfigFileForRegistryResponse {
  option deprecated = true;
  bytes docker_config_file = 1;
}
