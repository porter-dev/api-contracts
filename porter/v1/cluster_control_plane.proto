syntax = "proto3";

package porter.v1;

import "google/protobuf/timestamp.proto";
import "porter/v1/aws_assume_role.proto";
import "porter/v1/cloud_provider_credentials.proto";
import "porter/v1/contract.proto";
import "porter/v1/porter_app.proto";

message QuotaPreflightCheckRequest {
  int64 project_id = 1;
  string target_arn = 2;
  string external_id = 3;
  string region = 4;
}

message QuotaPreflightCheckResponse {}

message CreateAssumeRoleChainRequest {
  option deprecated = true;

  int64 project_id = 1;
  string source_arn = 2;
  string target_access_id = 3;
  string target_secret_key = 4;
  string target_session_token = 5;
  string target_arn = 6;
  string external_id = 7;
}

message CreateAssumeRoleChainResponse {
  option deprecated = true;

  int64 project_id = 1;
  string target_arn = 2;
}

message SaveAzureCredentialsRequest {
  option deprecated = true;
  int64 project_id = 1;
  string client_id = 2;
  string subscription_id = 3;
  string tenant_id = 4;
  bytes service_principal_secret = 5;
}

message SaveAzureCredentialsResponse {
  option deprecated = true;

  int64 project_id = 1;
  string credentials_identifier = 2;
}

message KubeConfigForClusterRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message KubeConfigForClusterResponse {
  string kube_config = 1;
}

message UpdateContractRequest {
  Contract contract = 1;
}

message UpdateContractResponse {
  ContractRevision contract_revision = 1;
}

message ClusterStatusRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message ClusterStatusResponse {
  int64 project_id = 1;
  int64 cluster_id = 2;
  string phase = 3;
  bool infrastructure_status = 4;
  bool control_plane_status = 5;
}

message DeleteClusterRequest {
  ContractRevision contract_revision = 1;
}

message DeleteClusterResponse {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message ListRepositoriesForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message ListRepositoriesForRegistryResponse {
  repeated Repository repositories = 1;
}

message Repository {
  string name = 1;
  string uri = 3;
}

message ListImagesForRepositoryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
  string repo_name = 3;
}

message ListImagesForRepositoryResponse {
  repeated Image images = 1;
}

message Image {
  string repository_name = 1;
  string tag = 2;
}

message TokenForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message TokenForRegistryResponse {
  string token = 1;
  google.protobuf.Timestamp expiry = 2;
}

message ReadContractRequest {
  ContractRevision contract_revision = 1;
}

message ReadContractResponse {
  string base64_contract = 1;
}

message ValidatePorterAppRequest {
  int64 project_id = 1;
  string deployment_target_id = 2;
  string commit_sha = 3;
  PorterApp application = 4;
}

message ValidatePorterAppResponse {
  PorterApp application = 1;
}

message ApplyPorterAppRequest {
  int64 project_id = 1;
  // deployment_target_id is the id of the deployment target where the application will be installed
  string deployment_target_id = 2;
  // application is the definition of the PorterApp to be applied
  PorterApp application = 3;
  // porter_app_revision_id is the id of the PorterAppRevision to be applied.  This is used by the CLI to provide updates to an existing application revision. If provided, application must be empty.
  string porter_app_revision_id = 4;
}

message ApplyPorterAppResponse {
  string porter_app_revision_id = 1;
  // cli_action is the action that the CLI should take after applying the PorterApp (at the time of writing, either build the image or track whether a predeploy job has completed)
  EnumCLIAction cli_action = 2;
}

enum EnumCLIAction {
  ENUM_CLI_ACTION_UNSPECIFIED = 0;
  ENUM_CLI_ACTION_BUILD = 1;
  ENUM_CLI_ACTION_TRACK_PREDEPLOY = 2;
}

service ClusterControlPlaneService {
  // UpdateCloudProviderCredentials creates or updates the credentials used for accessing the specific cloud
  rpc UpdateCloudProviderCredentials(UpdateCloudProviderCredentialsRequest) returns (UpdateCloudProviderCredentialsResponse) {}

  // QuotaPreflightCheck checks if the target account and region has sufficient resources (EIP addresses and VPCs) to provision a new cluster
  rpc QuotaPreflightCheck(QuotaPreflightCheckRequest) returns (QuotaPreflightCheckResponse) {}

  // CreateAssumeRoleChain creates a new assume role chain for a given project and checks if the target assumed role has sufficient permissions. Use UpdateCloudProviderCredentials instead.
  rpc CreateAssumeRoleChain(CreateAssumeRoleChainRequest) returns (CreateAssumeRoleChainResponse) {
    option deprecated = true;
  }

  // SaveAzureCredentials stores the new azure service principal credentials and creates the azure cluster identity. Deprecated. Use UpdateCloudProviderCredentials instead.
  rpc SaveAzureCredentials(SaveAzureCredentialsRequest) returns (SaveAzureCredentialsResponse) {
    option deprecated = true;
  }

  // KubeConfigForCluster gets a valid kubeconfig from the management cluster, for a given workload cluster
  rpc KubeConfigForCluster(KubeConfigForClusterRequest) returns (KubeConfigForClusterResponse) {}

  // UpdateContract takes in a Porter Contract, actioning upon it where necessary
  rpc UpdateContract(UpdateContractRequest) returns (UpdateContractResponse) {}

  // ReadContract returns the base64 encoded contract for a given cluster and project
  rpc ReadContract(ReadContractRequest) returns (ReadContractResponse) {}

  // ClusterStatus returns the status of a given workload cluster
  rpc ClusterStatus(ClusterStatusRequest) returns (ClusterStatusResponse) {}

  // DeleteCluster uninstalls system components from a given workload cluster before deleting it.
  // This should ultimately be wrapped into UpdateContract
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {}

  // TokenForRegistry returns a token for accessing a given registry
  rpc TokenForRegistry(TokenForRegistryRequest) returns (TokenForRegistryResponse) {}

  // ListRepositoriesForRegistry lists the repositories for a given registry, provided it is in the scope of the project id
  rpc ListRepositoriesForRegistry(ListRepositoriesForRegistryRequest) returns (ListRepositoriesForRegistryResponse) {}

  // ListImagesForRepository lists the repositories for a given registry, provided it is in the scope of the project id
  rpc ListImagesForRepository(ListImagesForRepositoryRequest) returns (ListImagesForRepositoryResponse) {}

  // ValidatePorterApp validates and hydrates a definition of a porter app, based on the porter.yaml file
  rpc ValidatePorterApp(ValidatePorterAppRequest) returns (ValidatePorterAppResponse) {}

  // ApplyPorterApp applies a porter app as defined by the provided porter.yaml file to a given deployment id
  rpc ApplyPorterApp(ApplyPorterAppRequest) returns (ApplyPorterAppResponse) {}

  // DockerConfigFileForRegistry returns a stringified config.json for accessing a given registry.
  // Deprecated. Use TokenForRegistry instead.
  rpc DockerConfigFileForRegistry(DockerConfigFileForRegistryRequest) returns (DockerConfigFileForRegistryResponse) {
    option deprecated = true;
  }

  // ECRTokenForRegistry returns a docker-compatible token for accessing a given ECR registry.
  // This cannot be deleted before TokenForRegistry supports AWS and we edit RegistryGetECRTokenHandler to call that endpoint.
  // Deprecated. Use TokenForRegistry instead.
  rpc ECRTokenForRegistry(ECRTokenForRegistryRequest) returns (ECRTokenForRegistryResponse) {
    option deprecated = true;
  }

  // AssumeRoleCredentials should be used vary sparingly, and ONLY for replacing AWS Integrations which have no workaround on the Porter API.
  // This endpoint returns temporary AWS credentials for a given AWS Account ID, and should not be expanded further to allow specifc role selection without being tied to a project and cluster.
  // Deprecated. This is no longer needed once ListRepositoriesForRegistry, ListImages, and CreateRepository supports AWS
  rpc AssumeRoleCredentials(AssumeRoleCredentialsRequest) returns (AssumeRoleCredentialsResponse) {
    option deprecated = true;
  }

  // AssumeRoleChainTargets gets the final destination target_arns for a given project.
  // Deprecated. Do not use.
  rpc AssumeRoleChainTargets(AssumeRoleChainTargetsRequest) returns (AssumeRoleChainTargetsResponse) {
    option deprecated = true;
  }

  // CertificateAuthorityData gets the certificate authority data for a customer cluster
  rpc CertificateAuthorityData(CertificateAuthorityDataRequest) returns (CertificateAuthorityDataResponse) {
    option deprecated = true;
  }

  // EKSBearerToken gets a bearer token for programatic access to an EKS cluster's kubernetes API.
  // Deprecated. Use KubeConfigForCluster instead.
  rpc EKSBearerToken(EKSBearerTokenRequest) returns (EKSBearerTokenResponse) {
    option deprecated = true;
  }
}

message EKSBearerTokenRequest {
  option deprecated = true;
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message EKSBearerTokenResponse {
  option deprecated = true;
  string token = 1;
}

message CertificateAuthorityDataRequest {
  option deprecated = true;
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message CertificateAuthorityDataResponse {
  option deprecated = true;
  string certificate_authority_data = 1;
}

message AssumeRoleChainTargetsRequest {
  option deprecated = true;
  string project_id = 1;
}

message AssumeRoleChainTargetsResponse {
  option deprecated = true;
  repeated AssumeRoleChainLink chain_links = 1;
}

message ECRTokenForRegistryRequest {
  option deprecated = true;
  int64 project_id = 1;
  string region = 2;
  string aws_account_id = 3;
}

message ECRTokenForRegistryResponse {
  option deprecated = true;
  string token = 1;
  google.protobuf.Timestamp expiry = 2;
}

message AssumeRoleCredentialsRequest {
  option deprecated = true;
  string aws_account_id = 1;
  int64 project_id = 2;
}

message AssumeRoleCredentialsResponse {
  option deprecated = true;
  string aws_access_id = 1;
  string aws_secret_key = 2;
  string aws_session_token = 3;
}

message DockerConfigFileForRegistryRequest {
  option deprecated = true;
  int64 project_id = 1;
  string registry_uri = 2;
}

message DockerConfigFileForRegistryResponse {
  option deprecated = true;
  bytes docker_config_file = 1;
}
