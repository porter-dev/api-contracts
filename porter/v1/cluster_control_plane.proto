syntax = "proto3";

package porter.v1;

import "google/protobuf/timestamp.proto";
import "porter/v1/aws_assume_role.proto";
import "porter/v1/cloud_provider_credentials.proto";
import "porter/v1/cluster.proto";
import "porter/v1/contract.proto";
import "porter/v1/eks.proto";
import "porter/v1/errors.proto";
import "porter/v1/gke.proto";
import "porter/v1/porter_app.proto";

message QuotaIncreaseRequest {
  int64 project_id = 1;
  //eks_preflight_values the values that AWS will use to make quota increases
  EKSPreflightValues eks_preflight_values = 2;
  // cloud_provider_credentials_id [REQUIRED] is the Porter credentials that will be used for provisioning a cluster.
  // These must be stored within Porter, prior to cluster creation. For AWS this refers to the last link in an assume role chain
  string cloud_provider_credentials_id = 3;
  //quota_increases list of quota increases to be requsted 
  repeated string quota_increases = 4;
}

message QuotaIncreaseResponse {
  //error if any of quota increases failed 
  Error error = 1;
}


message PreflightCheckRequest {
  int64 project_id = 1;
  // cloud_provider [REQUIRED] represents the provider that we will provisioning the cluster in
  EnumCloudProvider cloud_provider = 2;
  // cloud_provider_credentials_id [REQUIRED] is the Porter credentials that will be used for provisioning a cluster.
  // These must be stored within Porter, prior to cluster creation. For AWS this refers to the last link in an assume role chain
  string cloud_provider_credentials_id = 3;

  oneof preflight_values {
    //gke_preflight_values the values that GKE will use to perform preflight checks
    GKEPreflightValues gke_preflight_values = 4;
    //eks_preflight_values the values that AWS will use to perform preflight checks
    EKSPreflightValues eks_preflight_values = 5;

    //AKS aks_kind = 6;
  }
}

message PreflightCheckResponse {
  // preflight_checks keys are name of preflight check and error will be if the preflight checks fails, nil if it passes
  map<string, Error> preflight_checks = 1;
}

message QuotaPreflightCheckRequest {
  option deprecated = true;
  int64 project_id = 1;
  string target_arn = 2;
  string external_id = 3;
  string region = 4;
}

message QuotaPreflightCheckResponse {
  option deprecated = true;
}

message CreateAssumeRoleChainRequest {
  option deprecated = true;

  int64 project_id = 1;
  string source_arn = 2;
  string target_access_id = 3;
  string target_secret_key = 4;
  string target_session_token = 5;
  string target_arn = 6;
  string external_id = 7;
}

message CreateAssumeRoleChainResponse {
  option deprecated = true;

  int64 project_id = 1;
  string target_arn = 2;
}

message SaveAzureCredentialsRequest {
  option deprecated = true;
  int64 project_id = 1;
  string client_id = 2;
  string subscription_id = 3;
  string tenant_id = 4;
  bytes service_principal_secret = 5;
}

message SaveAzureCredentialsResponse {
  option deprecated = true;

  int64 project_id = 1;
  string credentials_identifier = 2;
}

message KubeConfigForClusterRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message KubeConfigForClusterResponse {
  string kube_config = 1;
}

message UpdateContractRequest {
  Contract contract = 1;
}

message UpdateContractResponse {
  ContractRevision contract_revision = 1;
}

message ClusterStatusRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message ClusterStatusResponse {
  int64 project_id = 1;
  int64 cluster_id = 2;
  string phase = 3;
  bool infrastructure_status = 4;
  bool control_plane_status = 5;
}

message DeleteClusterRequest {
  ContractRevision contract_revision = 1;
}

message DeleteClusterResponse {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message ListRepositoriesForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message ListRepositoriesForRegistryResponse {
  repeated Repository repositories = 1;
}

message Repository {
  string name = 1;
  string uri = 3;
}

message ListImagesForRepositoryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
  string repo_name = 3;
}

message ListImagesForRepositoryResponse {
  repeated Image images = 1;
}

message Image {
  string repository_name = 1;
  string tag = 2;
  string digest = 3;
  google.protobuf.Timestamp updated_at = 4;
}

message TokenForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message TokenForRegistryResponse {
  string token = 1;
  google.protobuf.Timestamp expiry = 2;
}

message ReadContractRequest {
  ContractRevision contract_revision = 1;
}

message ReadContractResponse {
  string base64_contract = 1;
}

message ValidatePorterAppRequest {
  int64 project_id = 1;
  string deployment_target_id = 2;
  string commit_sha = 3;
  PorterApp app = 4;
  Deletions deletions = 5;
}

message ValidatePorterAppResponse {
  PorterApp app = 1;
}

message ApplyPorterAppRequest {
  int64 project_id = 1;
  // deployment_target_id is the id of the deployment target where the app will be installed
  string deployment_target_id = 2;
  // app is the definition of the PorterApp to be applied
  PorterApp app = 3;
  // porter_app_revision_id is the id of the PorterAppRevision to be applied.  This is used by the CLI to provide updates to an existing app revision. If provided, app must be empty.
  string porter_app_revision_id = 4;
  // force_build is a flag that forces the app to rebuild, regardless of the existing tag. This is used on initial apply by the CLI.
  bool force_build = 5;
}

message ApplyPorterAppResponse {
  string porter_app_revision_id = 1;
  // cli_action is the action that the CLI should take after applying the PorterApp (at the time of writing, either build the image or track whether a predeploy job has completed)
  EnumCLIAction cli_action = 2;
}

message UpdateRevisionStatusRequest {
  int64 project_id = 1;
  // app_revision_id is the id of the PorterAppRevision
  string app_revision_id = 2;
  // revision_status is the new status of the revision
  EnumRevisionStatus revision_status = 3;
}

message UpdateRevisionStatusResponse {}

// DeletePorterAppRequest is the request object when deleting a porter app from a given project
message DeletePorterAppRequest {
  // project_id is the id of the project that the PorterApp belongs to
  int64 project_id = 1;
  // app_name is the name of the porter app to be deleted
  string app_name = 2;
}

// DeletePorterAppResponse is the response object when deleting a porter app from a given project
message DeletePorterAppResponse {
  // app_id is the id of the PorterApp that was deleted
  int64 app_id = 1;
}

// DeleteAppDeploymentRequest is the request object when removing a porter app from a given deployment target
message DeleteAppDeploymentRequest {
  int64 project_id = 1;
  // deployment_target_id is the id of the deployment target where the app is being uninstalled from
  string deployment_target_id = 2;
  // app_name is the name of the porter app to be uninstalled
  string app_name = 3;
}

// DeleteAppDeploymentResponse is the response object when removing a porter app from a given deployment target
message DeleteAppDeploymentResponse {}

message CurrentAppRevisionRequest {
  int64 project_id = 1;
  // app_id is the id of the PorterApp that is currently installed
  int64 app_id = 2;
  // deployment_target_id is the id of the deployment target where the app is installed
  string deployment_target_id = 3;
}

message AppRevision {
  // app is the definition of the PorterApp that is currently installed
  PorterApp app = 1;
  // status is the status of the revision
  string status = 2;
  // revision_number is the revision number respective to the application and deployment target
  uint64 revision_number = 3;
  // created_at is the time the revision was created
  google.protobuf.Timestamp created_at = 4;
  // updated_at is the time the revision was last updated
  google.protobuf.Timestamp updated_at = 5;
  // id is the id of the revision
  string id = 6;
  // deployment_target_id is the id of the deployment target where the revision occurs
  string deployment_target_id = 7;
}

message CurrentAppRevisionResponse {
  // revision is the currently deployed app revision for a given porter_app and deployment_target
  AppRevision app_revision = 1;
}

message ListAppRevisionsRequest {
  int64 project_id = 1;
  // app_id is the id of the PorterApp that is currently installed
  int64 app_id = 2;
  // deployment_target_id is the id of the deployment target where the app is installed
  string deployment_target_id = 3;
}

message ListAppRevisionsResponse {
  // app_revisions is the list of app revisions for the given app and deployment target
  repeated AppRevision app_revisions = 1;
}

message LatestAppRevisionsRequest {
  int64 project_id = 1;
  // deployment_target_id is the id of the deployment target to retrieve revisions from
  string deployment_target_id = 3;
}

message LatestAppRevisionsResponse {
  // app_revisions is the list of app revisions for the given deployment target
  repeated AppRevision app_revisions = 1;
}

message GetAppRevisionRequest {
  int64 project_id = 1;
  // app_revision_id is the id of the PorterAppRevision to return
  string app_revision_id = 2;
}

message GetAppRevisionResponse {
  // app_revision is the PorterAppRevision that was requested
  AppRevision app_revision = 1;
}

message PredeployStatusRequest {
  int64 project_id = 1;
  // app_revision_id is the revision id of the PorterApp which should have its predeploy status checked
  string app_revision_id = 2;
}

message PredeployStatusResponse {
  // predeploy_status is the status of the predeploy job
  EnumPredeployStatus predeploy_status = 1;
}

enum EnumPredeployStatus {
  ENUM_PREDEPLOY_STATUS_UNSPECIFIED = 0;
  // ENUM_PREDEPLOY_STATUS_IN_PROGRESS signifies the predeploy is still in progress.
  ENUM_PREDEPLOY_STATUS_IN_PROGRESS = 1;
  // ENUM_PREDEPLOY_STATUS_FAILED signifies the predeploy job failed.
  ENUM_PREDEPLOY_STATUS_FAILED = 2;
  // ENUM_PREDEPLOY_STATUS_SUCCESSFUL signifies the predeploy job was successful.
  ENUM_PREDEPLOY_STATUS_SUCCESSFUL = 3;
}

message DeploymentTargetDetailsRequest {
  int64 project_id = 1;
  string deployment_target_id = 2;
}

message DeploymentTargetDetailsResponse {
  // namespace is the namespace that the deployment target points to
  string namespace = 1;
  // cluster_id is the id of the cluster that the deployment target points to
  int64 cluster_id = 2;
}

enum EnumCLIAction {
  ENUM_CLI_ACTION_UNSPECIFIED = 0;
  // ENUM_CLI_ACTION_NONE signals the CLI to do nothing after applying the PorterApp.
  ENUM_CLI_ACTION_NONE = 1;
  // ENUM_CLI_ACTION_BUILD signals the CLI to build the image and call ApplyPorterApp again after a successful build.
  ENUM_CLI_ACTION_BUILD = 2;
  // ENUM_CLI_ACTION_TRACK_PREDEPLOY signals the CLI to track the progress of the predeploy job and call ApplyPorterApp again after a successful run.
  ENUM_CLI_ACTION_TRACK_PREDEPLOY = 3;
}

enum EnumRevisionStatus {
  ENUM_REVISION_STATUS_UNSPECIFIED = 0;
  // ENUM_REVISION_STATUS_PREDEPLOY signifies the predeploy job failed.
  ENUM_REVISION_STATUS_PREDEPLOY_FAILED = 1;
  // ENUM_REVISION_STATUS_DEPLOY_FAILED signifies the deploy job failed.
  ENUM_REVISION_STATUS_DEPLOY_FAILED = 2;
  // ENUM_REVISION_STATUS_BUILD_FAILED signifies the build failed.
  ENUM_REVISION_STATUS_BUILD_FAILED = 3;
}

message SeedAppRevisionsRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
  string release_name = 3;
  string namespace = 4;
}

message SeedAppRevisionsResponse {}

// EnvGroupVariablesRequest is the request object when retrieving the variables for a given EnvGroup
message EnvGroupVariablesRequest {
  int64 project_id = 1;
  string deployment_target_id = 2;
  EnvGroup env_group = 3;
}

// EnvGroupVariablesResponse is the response object when retrieving the variables for a given EnvGroup
message EnvGroupVariablesResponse {
  EnvGroupVariables env_group_variables = 1;
}

// LatestEnvGroupWithVariablesRequest is the request object when retrieving the latest EnvGroup and its variables for a given deployment target
message LatestEnvGroupWithVariablesRequest {
  int64 project_id = 1;
  string deployment_target_id = 2;
  string env_group_name = 3;
}

// LatestEnvGroupWithVariablesResponse is the response object when retrieving the latest EnvGroup and its variables for a given deployment target
message LatestEnvGroupWithVariablesResponse {
  EnvGroup env_group = 1;
  EnvGroupVariables env_group_variables = 2;
}

message UpdateAppImageRequest {
  int64 project_id = 1;
  string app_name = 2;
  string deployment_target_id = 3;
  string repository_url = 4;
  string tag = 5;
}

message UpdateAppImageResponse {
  string repository_url = 1;
  string tag = 2;
}

service ClusterControlPlaneService {
  // QuotaIncrease will auto request increases to the quota in a specific region given a list of quotas 
  rpc QuotaIncrease(QuotaIncreaseRequest) returns (QuotaIncreaseResponse) {}

  // UpdateCloudProviderCredentials creates or updates the credentials used for accessing the specific cloud
  rpc UpdateCloudProviderCredentials(UpdateCloudProviderCredentialsRequest) returns (UpdateCloudProviderCredentialsResponse) {}

  // QuotaPreflightCheck checks if the target account and region has sufficient resources (EIP addresses and VPCs) to provision a new cluster
  rpc QuotaPreflightCheck(QuotaPreflightCheckRequest) returns (QuotaPreflightCheckResponse) {
    option deprecated = true;
  }

  // PreflightCheck checks if the target account is able to provision a cluster
  rpc PreflightCheck(PreflightCheckRequest) returns (PreflightCheckResponse) {}

  // CreateAssumeRoleChain creates a new assume role chain for a given project and checks if the target assumed role has sufficient permissions. Use UpdateCloudProviderCredentials instead.
  rpc CreateAssumeRoleChain(CreateAssumeRoleChainRequest) returns (CreateAssumeRoleChainResponse) {
    option deprecated = true;
  }

  // SaveAzureCredentials stores the new azure service principal credentials and creates the azure cluster identity. Deprecated. Use UpdateCloudProviderCredentials instead.
  rpc SaveAzureCredentials(SaveAzureCredentialsRequest) returns (SaveAzureCredentialsResponse) {
    option deprecated = true;
  }

  // KubeConfigForCluster gets a valid kubeconfig from the management cluster, for a given workload cluster
  rpc KubeConfigForCluster(KubeConfigForClusterRequest) returns (KubeConfigForClusterResponse) {}

  // UpdateContract takes in a Porter Contract, actioning upon it where necessary
  rpc UpdateContract(UpdateContractRequest) returns (UpdateContractResponse) {}

  // ReadContract returns the base64 encoded contract for a given cluster and project
  rpc ReadContract(ReadContractRequest) returns (ReadContractResponse) {}

  // ClusterStatus returns the status of a given workload cluster
  rpc ClusterStatus(ClusterStatusRequest) returns (ClusterStatusResponse) {}

  // DeleteCluster uninstalls system components from a given workload cluster before deleting it.
  // This should ultimately be wrapped into UpdateContract
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {}

  // TokenForRegistry returns a token for accessing a given registry
  rpc TokenForRegistry(TokenForRegistryRequest) returns (TokenForRegistryResponse) {}

  // ListRepositoriesForRegistry lists the repositories for a given registry, provided it is in the scope of the project id
  rpc ListRepositoriesForRegistry(ListRepositoriesForRegistryRequest) returns (ListRepositoriesForRegistryResponse) {}

  // ListImagesForRepository lists the repositories for a given registry, provided it is in the scope of the project id
  rpc ListImagesForRepository(ListImagesForRepositoryRequest) returns (ListImagesForRepositoryResponse) {}

  // ValidatePorterApp validates and hydrates a definition of a porter app, based on the porter.yaml file
  rpc ValidatePorterApp(ValidatePorterAppRequest) returns (ValidatePorterAppResponse) {}

  // ApplyPorterApp applies a porter app as defined by the provided porter.yaml file to a given deployment id
  rpc ApplyPorterApp(ApplyPorterAppRequest) returns (ApplyPorterAppResponse) {}

  // UpdateRevisionStatus updates the status of a revision
  rpc UpdateRevisionStatus(UpdateRevisionStatusRequest) returns (UpdateRevisionStatusResponse) {}

  // DeletePorterApp deletes all instances of a porter app across deployment targets in a given project
  rpc DeletePorterApp(DeletePorterAppRequest) returns (DeletePorterAppResponse) {}

  // DeleteAppDeployment deletes a porter app from a given deployment target
  rpc DeleteAppDeployment(DeleteAppDeploymentRequest) returns (DeleteAppDeploymentResponse) {}

  // CurrentAppRevision returns the currently deployed app revision for a given porter_app and deployment_target
  rpc CurrentAppRevision(CurrentAppRevisionRequest) returns (CurrentAppRevisionResponse) {}

  rpc ListAppRevisions(ListAppRevisionsRequest) returns (ListAppRevisionsResponse) {}

  // LatestAppRevisions returns the currently deployed app revisions for a given deployment_target
  rpc LatestAppRevisions(LatestAppRevisionsRequest) returns (LatestAppRevisionsResponse) {}

  // GetAppRevision returns the app revision for a given app revision id
  rpc GetAppRevision(GetAppRevisionRequest) returns (GetAppRevisionResponse) {}

  // PredeployStatus returns the status of the predeploy job for a given app revision
  rpc PredeployStatus(PredeployStatusRequest) returns (PredeployStatusResponse) {}

  // DeploymentTargetDetails returns the details of a deployment target job given the id.  This is a work-around to moving all namespace-related
  // logic to CCP and should only be used to support metrics and logging (and confirming cluster RBAC). This will fail once
  // we start using deployment targets that do not have a selector kind of "namespace"
  rpc DeploymentTargetDetails(DeploymentTargetDetailsRequest) returns (DeploymentTargetDetailsResponse) {}

  // SeedAppRevision seeds app revisions for a given project id, cluster id, release name, namespace.  It should only be called
  // from the Cluster Control Plane CLI and should be removed once all legacy users are migrated to the new apply validate.
  rpc SeedAppRevisions(SeedAppRevisionsRequest) returns (SeedAppRevisionsResponse) {}

  // EnvGroupVariables returns the variables for a given env group name and version
  rpc EnvGroupVariables(EnvGroupVariablesRequest) returns (EnvGroupVariablesResponse) {}

  // LatestEnvGroupWithVariables returns the latest env group and variables for a given env group name in the given deployment target
  rpc LatestEnvGroupWithVariables(LatestEnvGroupWithVariablesRequest) returns (LatestEnvGroupWithVariablesResponse) {}

  // UpdateAppImage updates the image of a porter app and applies the new app revision to the deployment target.
  rpc UpdateAppImage(UpdateAppImageRequest) returns (UpdateAppImageResponse) {}

  // DockerConfigFileForRegistry returns a stringified config.json for accessing a given registry.
  // Deprecated. Use TokenForRegistry instead.
  rpc DockerConfigFileForRegistry(DockerConfigFileForRegistryRequest) returns (DockerConfigFileForRegistryResponse) {
    option deprecated = true;
  }

  // ECRTokenForRegistry returns a docker-compatible token for accessing a given ECR registry.
  // This cannot be deleted before TokenForRegistry supports AWS and we edit RegistryGetECRTokenHandler to call that endpoint.
  // Deprecated. Use TokenForRegistry instead.
  rpc ECRTokenForRegistry(ECRTokenForRegistryRequest) returns (ECRTokenForRegistryResponse) {
    option deprecated = true;
  }

  // AssumeRoleCredentials should be used vary sparingly, and ONLY for replacing AWS Integrations which have no workaround on the Porter API.
  // This endpoint returns temporary AWS credentials for a given AWS Account ID, and should not be expanded further to allow specifc role selection without being tied to a project and cluster.
  // Deprecated. This is no longer needed once ListRepositoriesForRegistry, ListImages, and CreateRepository supports AWS
  rpc AssumeRoleCredentials(AssumeRoleCredentialsRequest) returns (AssumeRoleCredentialsResponse) {
    option deprecated = true;
  }

  // AssumeRoleChainTargets gets the final destination target_arns for a given project.
  // Deprecated. Do not use.
  rpc AssumeRoleChainTargets(AssumeRoleChainTargetsRequest) returns (AssumeRoleChainTargetsResponse) {
    option deprecated = true;
  }

  // CertificateAuthorityData gets the certificate authority data for a customer cluster
  rpc CertificateAuthorityData(CertificateAuthorityDataRequest) returns (CertificateAuthorityDataResponse) {
    option deprecated = true;
  }

  // EKSBearerToken gets a bearer token for programatic access to an EKS cluster's kubernetes API.
  // Deprecated. Use KubeConfigForCluster instead.
  rpc EKSBearerToken(EKSBearerTokenRequest) returns (EKSBearerTokenResponse) {
    option deprecated = true;
  }
}

message EKSBearerTokenRequest {
  option deprecated = true;
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message EKSBearerTokenResponse {
  option deprecated = true;
  string token = 1;
}

message CertificateAuthorityDataRequest {
  option deprecated = true;
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message CertificateAuthorityDataResponse {
  option deprecated = true;
  string certificate_authority_data = 1;
}

message AssumeRoleChainTargetsRequest {
  option deprecated = true;
  string project_id = 1;
}

message AssumeRoleChainTargetsResponse {
  option deprecated = true;
  repeated AssumeRoleChainLink chain_links = 1;
}

message ECRTokenForRegistryRequest {
  option deprecated = true;
  int64 project_id = 1;
  string region = 2;
  string aws_account_id = 3;
}

message ECRTokenForRegistryResponse {
  option deprecated = true;
  string token = 1;
  google.protobuf.Timestamp expiry = 2;
}

message AssumeRoleCredentialsRequest {
  option deprecated = true;
  string aws_account_id = 1;
  int64 project_id = 2;
}

message AssumeRoleCredentialsResponse {
  option deprecated = true;
  string aws_access_id = 1;
  string aws_secret_key = 2;
  string aws_session_token = 3;
}

message DockerConfigFileForRegistryRequest {
  option deprecated = true;
  int64 project_id = 1;
  string registry_uri = 2;
}

message DockerConfigFileForRegistryResponse {
  option deprecated = true;
  bytes docker_config_file = 1;
}
