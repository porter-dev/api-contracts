syntax = "proto3";

package porter.v1;

import "google/protobuf/timestamp.proto";
import "porter/v1/cloud_provider_credentials.proto";
import "porter/v1/contract.proto";

message QuotaPreflightCheckRequest {
  int64 project_id = 1;
  string target_arn = 2;
  string external_id = 3;
  string region = 4;
}

message QuotaPreflightCheckResponse {}

message CreateAssumeRoleChainRequest {
  int64 project_id = 1;
  string source_arn = 2;
  string target_access_id = 3;
  string target_secret_key = 4;
  string target_session_token = 5;
  string target_arn = 6;
  string external_id = 7;
}

message CreateAssumeRoleChainResponse {
  int64 project_id = 1;
  string target_arn = 2;
}

message SaveAzureCredentialsRequest {
  int64 project_id = 1;
  string client_id = 2;
  string subscription_id = 3;
  string tenant_id = 4;
  bytes service_principal_secret = 5;
}

message SaveAzureCredentialsResponse {
  int64 project_id = 1;
  string credentials_identifier = 2;
}

message EKSBearerTokenRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message EKSBearerTokenResponse {
  string token = 1;
}

message CertificateAuthorityDataRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message CertificateAuthorityDataResponse {
  string certificate_authority_data = 1;
}

message AssumeRoleChainTargetsRequest {
  string project_id = 1;
}

message AssumeRoleChainTargetsResponse {
  repeated AssumeRoleChainLink chain_links = 1;
}

message KubeConfigForClusterRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message KubeConfigForClusterResponse {
  string kube_config = 1;
}

message UpdateContractRequest {
  Contract contract = 1;
}

message UpdateContractResponse {
  ContractRevision contract_revision = 1;
}

message ClusterStatusRequest {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message ClusterStatusResponse {
  int64 project_id = 1;
  int64 cluster_id = 2;
  string phase = 3;
  bool infrastructure_status = 4;
  bool control_plane_status = 5;
}

message DeleteClusterRequest {
  ContractRevision contract_revision = 1;
}

message DeleteClusterResponse {
  int64 project_id = 1;
  int64 cluster_id = 2;
}

message ECRTokenForRegistryRequest {
  int64 project_id = 1;
  string region = 2;
  string aws_account_id = 3;
}

message ECRTokenForRegistryResponse {
  string token = 1;
  google.protobuf.Timestamp expiry = 2;
}

message AssumeRoleCredentialsRequest {
  string aws_account_id = 1;
  int64 project_id = 2;
}

message AssumeRoleCredentialsResponse {
  string aws_access_id = 1;
  string aws_secret_key = 2;
  string aws_session_token = 3;
}

message ListRepositoriesForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message ListRepositoriesForRegistryResponse {
  repeated Repository repositories = 1;
}

message Repository {
  string name = 1;
  string uri = 3;
}

message ListImagesForRepositoryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
  string repo_name = 3;
}

message ListImagesForRepositoryResponse {
  repeated Image images = 1;
}

message Image {
  string repository_name = 1;
  string tag = 2;
}

message TokenForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message TokenForRegistryResponse {
  string token = 1;
  google.protobuf.Timestamp expiry = 2;
}

message DockerConfigFileForRegistryRequest {
  int64 project_id = 1;
  string registry_uri = 2;
}

message DockerConfigFileForRegistryResponse {
  bytes docker_config_file = 1;
}

message ReadContractRequest {
  ContractRevision contract_revision = 1;
}

message ReadContractResponse {
  string base64_contract = 1;
}

service ClusterControlPlaneService {
  // UpdateCloudProviderCredentials creates or updates the credentials used for accessing the specific cloud
  rpc UpdateCloudProviderCredentials(UpdateCloudProviderCredentialsRequest) returns (UpdateCloudProviderCredentialsResponse) {}

  // QuotaPreflightCheck checks if the target account and region has sufficient resources (EIP addresses and VPCs) to provision a new cluster
  rpc QuotaPreflightCheck(QuotaPreflightCheckRequest) returns (QuotaPreflightCheckResponse) {}

  // CreateAssumeRoleChain creates a new assume role chain for a given project and checks if the target assumed role has sufficient permissions
  rpc CreateAssumeRoleChain(CreateAssumeRoleChainRequest) returns (CreateAssumeRoleChainResponse) {}

  // AssumeRoleChainTargets gets the final destination target_arns for a given project
  rpc AssumeRoleChainTargets(AssumeRoleChainTargetsRequest) returns (AssumeRoleChainTargetsResponse) {}

  // SaveAzureCredentials stores the new azure service principal credentials and creates the azure cluster identity
  rpc SaveAzureCredentials(SaveAzureCredentialsRequest) returns (SaveAzureCredentialsResponse) {}

  // CertificateAuthorityData gets the certificate authority data for a customer cluster
  rpc CertificateAuthorityData(CertificateAuthorityDataRequest) returns (CertificateAuthorityDataResponse) {}

  // EKSBearerToken gets a bearer token for programatic access to an EKS cluster's kubernetes API
  rpc EKSBearerToken(EKSBearerTokenRequest) returns (EKSBearerTokenResponse) {}

  // KubeConfigForCluster gets a valid kubeconfig from the management cluster, for a given workload cluster
  rpc KubeConfigForCluster(KubeConfigForClusterRequest) returns (KubeConfigForClusterResponse) {}

  // UpdateContract takes in a Porter Contract, actioning upon it where necessary
  rpc UpdateContract(UpdateContractRequest) returns (UpdateContractResponse) {}

  // ReadContract returns the base64 encoded contract for a given cluster and project
  rpc ReadContract(ReadContractRequest) returns (ReadContractResponse) {}

  // ClusterStatus returns the status of a given workload cluster
  rpc ClusterStatus(ClusterStatusRequest) returns (ClusterStatusResponse) {}

  // DeleteCluster uninstalls system components from a given workload cluster before deleting it.
  // This should ultimately be wrapped into UpdateContract
  rpc DeleteCluster(DeleteClusterRequest) returns (DeleteClusterResponse) {}

  // ECRTokenForRegistry returns a docker-compatible token for accessing a given ECR registry
  rpc ECRTokenForRegistry(ECRTokenForRegistryRequest) returns (ECRTokenForRegistryResponse) {}

  // AssumeRoleCredentials should be used vary sparingly, and ONLY for replacing AWS Integrations which have no workaround on the Porter API.
  // This endpoint returns temporary AWS credentials for a given AWS Account ID, and should not be expanded further to allow specifc role selection without being tied to a project and cluster
  rpc AssumeRoleCredentials(AssumeRoleCredentialsRequest) returns (AssumeRoleCredentialsResponse) {}

  // TokenForRegistry returns a token for accessing a given registry
  rpc TokenForRegistry(TokenForRegistryRequest) returns (TokenForRegistryResponse) {}

  // DockerConfigFileForRegistry returns a stringified config.json for accessing a given registry
  rpc DockerConfigFileForRegistry(DockerConfigFileForRegistryRequest) returns (DockerConfigFileForRegistryResponse) {}

  // ListRepositoriesForRegistry lists the repositories for a given registry, provided it is in the scope of the project id
  rpc ListRepositoriesForRegistry(ListRepositoriesForRegistryRequest) returns (ListRepositoriesForRegistryResponse) {}

  // ListImagesForRepository lists the repositories for a given registry, provided it is in the scope of the project id
  rpc ListImagesForRepository(ListImagesForRepositoryRequest) returns (ListImagesForRepositoryResponse) {}
}
